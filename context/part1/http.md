# 其它

## HTTP

### form-data: 

就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；
由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。

### x-www-form-urlencoded：

就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如,name=Java&age = 23

### Cookie/Session

1. 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。

2. 发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来

3. 这种做法就是在客户端保持状态。 

4. 发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。

具体来说**cookie机制**采用的是在客户端保持状态的方案，而**session机制**采用的是在服务器端保持状态的方案。

正统的cookie分发是通过**扩展HTTP协议**来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 

 cookie的内容主要包括：**名字，值，过期时间，路径和域**。

而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。意思是麦当劳的会员卡只能在麦当劳的店里出示，如果某家分店还发行了自己的会员卡，那么进这家店的时候除了要出示麦当劳的会员卡，还要出示这家店的会员卡。 

>AngularJS

*AngularJS 的 Controller 应该只管理 $scope 里面的对象（用 watching 或者 手动操作）而不是承担过多过分重的东西。*

> 401 Unauthorized — The user is not logged in

> 403 Forbidden — The user is logged in but isn’t allowed access

> 419 Authentication Timeout (non standard) — Session has expired

> 440 Login Timeout (Microsoft only) — Session has expired

在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。

而Web应用程序是使用HTTP协议传输数据的。**HTTP协议是无状态的协议。**一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。

Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。

给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。

* Cookie   本地裸奔(本地存储数据)

* Session  本地装纯情（本地存了索引，异地存储数据）

* Certificate  本地与异地暗号沟通，暗语解析（本地私钥加密，异地公钥解密，异地储存数据）
**当然是Certificate安全**

Cookie只是一个普通的文本文件，那里面包含的字符串可以直接用记事本打开并进行编辑。因此任何人在任何电脑上都可以伪造一个包含有他人用户名 的 Cookie，从而实现对他人身份的冒用。

要解决这个问题，就要在Cookie中附加一项信息，这个信息需要具有以下特性：

1. 和该用户一一对应；
2. 伪 造难度大。这些内容和用户名一起，以Cookie的形式发送给用户的浏览器。并且，服务器必须能够记住这项内容，以便用户再次访问的时候进行核对。

另一种可以加以利用的信息是用户访问时的Session id。因为Session id是一个由系统随机产生的、无规律的、长度较长的字符串，因此它很难被伪造。

要把它和用户对应起来，我们需要在数据库中添加一个表，这个表至少有两个字 段，一个是用户名，一个是Session id。

当用户首次登录的时候，我们把当前的Session id和用户名分别用Cookie发送给用户，同时，把这两项作为一条记录插入数据库。
这样，当用户再次访问的时候，服务器就可以读取客户端发来的这两个 Cookie，并且用它们的值和数据库中的记录比对。
如果在数据库中找到了相应记录，就说明这台电脑的确是该用户上次登录时使用的电脑，进而可以为该用户自动登录。

### Filter拦截

用户可能为了方便，自行修改Cookie中的有效期，从而达到长期自动登录的目的。对某些存有敏感信息的网站来说，这样做并不安全。当用户长时间没有使用他的电脑，或者将电脑遗弃、转让了，而保存于其中的Cookie仍然是有效的，这就为用户和网站带来潜在的风险。

要解决这个问题，我们可以在数据库中增加一个字段，用以记录自动登录的过期日。这样，是否执行自动登录就不再以客户端的Cookie有效期为准，而 是以服务器端数据库中的信息为准。当我们想要调整用户自动登录的有效期的时候，只需要修改数据库中相应的日期字段即可，因而这一过程变得更加安全。

### Ping

Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明。

#### 因特网包探索器

它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。

ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。通常的情况下你如果不用作服务器或者进行网络测试，可以放心的选中它，保护你的电脑。

后面的time=1244ms 是响应时间，这个时间越小，说明你连接这个地址速度越快

### DOS命令

**DOS命令**，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。

DOS命令不区分大小写，比如C盘的Program Files，在dos命令中完全可以用`"progra~1"`代替，加上英文引号是因为名称的中间有空格（即多于一个词），这一点是初学者经常忽略的。

1. 查看目录内容命令 DIR
2. 指定可执行文件搜索目录 PATH
3. 创建目录命令 MD
4. 打开指定目录命令 CD
5. 删除当前指定的子目录命令 RD
6. 改变当前盘符命令 C:
7. 文件复制命令 COPY
8. 显示文本文件内容命令 TYPE
9. 更改文件名命令 REN
10. 删除文件命令 DEL
11. 清除屏幕命令 CLS

**特殊命令**

重复上一次输入的命令，可以使用F3键来完成，同时DOS下存在一个doskey的命令记录器，在命令行上执行doskey后将可以实现以下功能：
1. 向上箭头"↑"和向下箭头"↓"-----回看上一次执行的命令
2. "Ctrl+C" 组合键或"Break"键 -----中断操作
3. 鼠标操作"标记" -----------------用来选中文本
4. 鼠标操作"粘贴" -----------------用来把剪贴板内容粘贴到提示符下
5. "F7"键 --------------------------查看及执行用过的命令
6. "/?" ----------------------------指定命令帮助
7. ">" 及">>" ----------------------文件重定向

*参数：命令+ > +写入路径\文件名*

### FPS

FPS与分辨率、显卡处理能力的关系如下：
处理能力=分辨率×刷新率。这也就是为什么在玩游戏时，分辨率设置得越大，画面就越不流畅的原因了。

## package.json文件

每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。

package.json文件就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（*遵守“大版本.次要版本.小版本”的格式*）。

scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。

**dependencies**字段指定了项目运行所依赖的模块，**devDependencies**指定项目开发所需要的模块。

对应的版本可以加上各种限定，主要有以下几种：

* 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。

* 波浪号（tilde）+指定版本：比如~

*1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。*

* 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。

* latest：安装最新版本。

package.json文件可以手工编写，也可以使用**npm init**命令自动生成。

如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。

`$ npm install express --save  $ npm install express --save-dev`

*上面代码表示单独安装express模块，--save参数表示将该模块写入dependencies属性，--save-dev表示将该模块写入devDependencies属性。*

peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。

`{
  "name": "chai-as-promised",
  "peerDependencies": {
    "chai": "1.x"
  }}`

*上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。
注意，从npm 3.0版开始，peerDependencies不再会默认安装了。*

bin项用来指定各个内部命令对应的可执行文件的位置。

someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。

因此，像下面这样的写法可以采用简写。
`
scripts: {  
  start: './node_modules/someTool/someTool.js build'}
// 简写为
scripts: {  
  start: 'someTool build'}`

所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。

main字段指定了加载的入口文件，require('moduleName')就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。

**config字段用于添加命令行的环境变量。**
下面是一个package.json文件。
`
{
  "name" : "foo",
  "config" : { "port" : "8080" },
  "scripts" : { "start" : "node server.js" }}`

然后，在server.js脚本就可以引用config字段的值。
```bash
http
  .createServer(...)
  .listen(process.env.npm_package_config_port)
```

用户执行npm run start命令时，这个脚本就可以得到值。

`$ npm run start`
用户可以改变这个值。
`$ npm config set foo:port 80`

browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。
`"browser": {
  "tipso": "./node_modules/tipso/src/tipso.js"},`

## JavaScript

JS是一种轻量级的脚本语言。所谓“脚本语言”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。
JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。

目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。

从语法角度看，JavaScript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。阅读本书的过程中，你会震惊地发现，JavaScript 语法是多么的灵活。

以浏览器为例，它提供的额外 API 可以分成三大类。

>浏览器控制类：操作浏览器

>DOM 类：操作网页的各种元素

>Web 类：实现互联网的各种功能

Node 项目使得 JavaScript 可以用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实。

### 数据库操作

JavaScript 甚至也可以用来操作数据库。**NoSQL**数据库这个概念，本身就是在 JSON（JavaScript Object Notation，JavaScript 对象表示法）格式的基础上诞生的，大部分 NoSQL 数据库允许 JavaScript 直接操作。基于 SQL 语言的开源数据库 PostgreSQL 支持 JavaScript 作为操作语言，可以部分取代 SQL 查询语言。

PhoneGap 项目就是将 JavaScript 和 HTML5 打包在一个容器之中，使得它能同时在 iOS 和安卓上运行。

NoSQL，泛指非关系型的数据库。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。

### 事件驱动和非阻塞式设计

JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。

进入控制台以后，就可以在提示符后输入代码，然后按Enter键，代码就会执行。如果按Shift + Enter键，就是代码换行，不会触发执行。

### 异步编程

Javascript语言的执行环境是"单线程"（single thread）。所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。

为了解决这个问题，Javascript语言将任务的执行模式分成两种：**同步（Synchronous）**和**异步（Asynchronous）**。

**"同步模式"**就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；

**"异步模式"**则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

"异步模式"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，"异步模式"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。

采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。

**回调函数**的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。

#### 一、回调函数

#### 二、事件监听
```bash
f1.on('done', f2);
f1.trigger('done');
```
这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。

#### 三、发布/订阅
```bash
jQuery.publish("done");
jQuery.subscribe("done", f2);
```
取消订阅（unsubscribe）
```bash
jQuery.unsubscribe("done", f2);
```
#### 四、Promises对象

Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。

简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：
```bash
f1().then(f2);
#f1要进行如下改写（这里使用的是jQuery的实现）：
　　function f1(){
　　　　var dfd = $.Deferred();
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　dfd.resolve();
　　　　}, 500);
　　　　return dfd.promise;
　　}
```
这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。
比如，指定多个回调函数：

`f1().then(f2).then(f3);`

再比如，指定发生错误时的回调函数：

`f1().then(f2).fail(f3);`

它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。

解决异步问题方法大致包括：直接回调、pub/sub模式(事件模式)、异步库控制库(例如async、when)、promise、Generator等。

**Promise**

Promise翻译成中文为承诺，个人理解是异步完成之后，就会给外部一个结果（成功或失败），并承诺结果不再发生改变。换句话就是Promise反应了一个操作的最终返回结果值(A promise represents the eventual value returned from the single completion of an operation)。目前Promise已经引入到ES6规范里面，Chrome、firefox等高级浏览器已经在内部实现了该原生方法，使用起来相当方便。

then方法用于指定异步事件完成之后的回调函数。

这个方法可以说是Promise的灵魂方法，该方法让Promise充满了魔力。有如下几个具体表现：

* then方法返回Promise。这样就实现了多个异步操作的串行操作。

一个Promise里面的回调函数是共享value的，在结果处理中value作为参数传递给相应的回调函数，如果value是对象，那就要小心不要轻易修改value的值。

#### Generator 

上面所有的方法均是基于回调函数来完成异步操作的，无非是对回调函数进行封装而已。ES6里面提出了Generator，增加了解决异步操作的途径，不再依据回调函数来完成。

Generator最大的特点就是可以实现函数的暂停、重启，这个特性非常有利于解决异步操作。将Generator的暂停与promise的异常处理结合起来，可以比较优雅地解决异步编程问题。具体实现参考：Kyle Simpson

##### 异常处理
1. 异步事件包括两个环节：发出异步请求、结果处理，这两个环节通过event loop来连接起来。那么try catch来进行异常捕获的时候就需要分来捕获。

2. promise实现异常的传递，这带来一些好处，在实际项目中保证代码不被阻塞。但是如果异步事件比较多的时候，不容易找出到底是那个异步事件产生了异常。

把异常处理放到最后进行处理，这样当其中存在某个环节出现异常，我们无法准确知道到底是哪个事件产生的。

jQuery中也实现了异步操作，但是在实现上不符合promise/A+规范，主要表现在以下几个方面：
a.参数的个数：标准的Promise只能接受一个参数，而jQuery中则可以传递多个参数

JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。

## URI

URI（统一资源定位符）指向它，每种资源对应一个特定的URI。

要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。
RESTful架构：

1. 每一个URI代表一种资源；
2. 客户端和服务器之间，传递这种资源的某种表现层；
3. 客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

*RESTful架构有一些典型的设计误区。*

最常见的一种设计错误，就是URI包含动词。因为"资源"表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。

>GET /zoos：列出所有动物园

>POST /zoos：新建一个动物园

>GET /zoos/ID：获取某个指定动物园的信息

>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）

>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）

>DELETE /zoos/ID：删除某个动物园

>GET /zoos/ID/animals：列出某个指定动物园的所有动物

>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物

>?limit=10：指定返回记录的数量

>?offset=10：指定返回记录的开始位置。

>?page=2&per_page=100：指定第几页，以及每页的记录数。

>?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。

>?animal_type_id=1：指定筛选条件

### 幂等

**什么是幂等（Idempotency）？**简单来说，一个操作如果具有任意多次执行所产生的影响均与一次执行的影响相同，我们就称之为幂等。

那么幂等又该如何实现呢？“多次执行所产生的影响均与一次执行的影响相同”，简而言之，我们需要一个 Dedup（去重）的机制。这往往有很多不同的实现方法，但是有两个很关键的因素：

一是Idempotency Key（幂等令牌）。也就是客户端和服务器端通过什么来识别这实际上是同一个请求，或是同一个请求的多次 retry（尝试）。这往往需要双方又一个既定的协议。往往是类似账单号或者交易 token（令牌）这样一个可以唯一标识同一个请求意愿的元素。通常由客户端生成。