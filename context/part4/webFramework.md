# 前端架构

* **架构是对客观不足的妥协，规范是对主观不足的妥协。**
* 当“开发”正式化，我们需求的软件就变得：**功能繁杂、管理统一、多入口。**
* 机器的发展和软件的需求扩大和细化，我们开始出现了用户界面（User Interface）的概念和最适合用于界面的语言——标记语言（Markup Language）。当然，ML不是为UI而生的，它只是十分适合UI，所以才和UI坠入爱河。
* 因为有了更高UI的需求，所以代码才正式被分化为描述做什么（业务逻辑）和有什么（UI）的两部分，因为我们开发时没办法在两种思维方式下同时工作，开发时的人脑是单线程的。我们所看到的同时进行UI和逻辑开发只不过是我们学会了在两种模式下快速切换，看起来像同时进行，而不是真正的同时进行。
* UI和逻辑分开了两种语言来写，但是它们也要放在同一个项目中，因为它们原本就是要一起工作的。即使是分开，也需要相连，因为这是它们本来要解决的问题。
* *谁也没办法解决UI和逻辑代码分化后的一个哲学问题——UI和逻辑是一起的，但是它们却不是一起的。*

## MVC(Model-View-Controller)

* 界面被分到了View，数据分到了载体Model上由Model“携带”，业务集中在Controller中，而推动业务的事件由用户与View交互，通过View向Controller发动。
* `MVC的其中一个缺点便是没有明确的定义，所以不同的实现（比如Struts和http://ASP.NET MVC）细节上都是不一样的。`
* MVC的一般流程是这样的：View（界面）触发事件--》Controller（业务）处理了业务，然后触发了数据更新--》不知道谁更新了Model的数据--》Model（带着数据）回到了View--》View更新数据
* 许多时候并不是一种模式不好，而是因为人没办法执行，比如不容易理解，我们就会选择容易理解的方式。计算机依赖摩尔定律用数量的增长来解决问题，而人是用方式的改变来解决问题的。

## MVP(Model-View-Presenter)

## MVVM(Model-View-ViewModel)
* ViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据“绑定”的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。原理都是为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。
* 我们依然要解决的问题是用户交互与数据更新的问题，还有维护等等的问题。
* 我们会更倾向于用MVC模式，因为在Web层面，我们更倾向于一次性更新数据。所有问题都不是问题，就算有问题也要解决问题。实际上，现在Web MVVM主要并不是用在了Web或者Wap上，而是移动App上。按照前面的说法，只可能是：HTML+JS比原生在一些场景上更适合Native在移动App上比Web上更适合使用MVVM。**我们不一定需要MVVM，但我们一定需要更强大的方式去解决不断膨胀的Web需求。**

* 我们可以预见的是：

> 会有更强大的浏览器
> 会有更强大的JavaScript或者框架
> 会有更加适合的模式