# JS基础相关

### JS是一种*弱类型动态*语言

#### 强、弱类型，静态、动态类型
> 强、弱类型
> * 强类型strongly typed: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。
> * 弱类型weakly typed: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型
> * 弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。 这样的结果是：容易产生forbidden behaviours，所以是弱类型的

> 动态、静态类型
1. 静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;
2. 动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。
3. 误区大家觉得C语言要写int a, int b之类的，Python不用写(可以直接写a, b)，所以C是静态，Python是动态。这么理解是不够准确的。譬如Ocaml是静态类型的，但是也可以不用明确地写出来。。
Ocaml是静态隐式类型

> 静态类型可以分为两种：
> * 如果类型是语言语法的一部分，在是explicitly typed显式类型；
> * 如果类型通过编译时推导，是implicity typed隐式类型, 比如ML和Haskell

> 下面是些例子
>> 无类型： 汇编
弱类型、静态类型 ： C/C++
弱类型、动态类型检查： Perl/PHP
强类型、静态类型检查 ：Java/C#
强类型、动态类型检查 ：Python, Scheme
静态显式类型 ：Java/C
静态隐式类型 ：Ocaml, Haskell

![语言类型](./images/pic1.png)

#### 相关概念
> Program Errors
> * trapped errors。导致程序终止执行，如除0，Java中数组越界访问
> * untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址
> Forbidden Behaviours
> * 语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.
> Well behaved、ill behaved

#### 系统类型的区别
+ 类型系统的一些概念，众说纷纭，使用上也比较乱。有些东西，甚至不好严格定义。

* 关于强弱类型的定义实际上是type checking的概念。 static type checking才是指的能在compile time完全的检测出forbidden behaviors。还有，这里的forbidden behavior还是只与type相关的错误，比如null pointer dereference就不属于这类trapped behavior。然而，基本上所有industry languages都会有dynamic check才能保证type check的完整性，比如array bounds check，就必须要dynamic time check。正是由于不能完全static type checking，才有strong/weak typed这两个概念，他们就是指有多少forbidden behaviors能在compile time检查到。所以，确实如你所说没有一个明确的界限界定强弱，也因此在学术上事实是没有strong/weak的个概念。

****************************************************************************************************
****************************************************************************************************

### javascript语句
* JavaScript代码由语句构成，表明了执行过程的流程、限定和约定，形式上可以是单行语句，也可以是由大括号括起来的复合语句。语句由分号来分隔。语句是“使某事发生”的指令，不存在返回值一说；
* 当语句位于以下地点之一时，可以省略分号（不会出现语法错误，但可能造成执行阶段的错误）：
> 一行的最后
整个代码文件的最后
在语法分隔符之前（如复合语句的大括号“}”）
复合语句的大括号“}”之后
* 其它情况下遗漏分号，会在语法分析过程中报错，全部代码完全不执行。

#### 语句中比较特殊的一类是表达式语句，表示“只有表达式，没有其它语法元素的语句”，
* 例如：
`1+2+3;`
* 就是一个表达式语句。

****************************************************************************************************
****************************************************************************************************

### javascript表达式(expression)
* 表达式：是由运算元和运算符(可选)构成，并产生运算结果的语法结构。
> 基本表达式（Primary Expression）
this、null、arguments等内置的关键字
变量。即一个已声明的标识符
字面量。仅包括数字字面量、布尔值字面量、字符串字面量、正则字面量
分组表达式，即用来表示立刻进行计算的
这类表达式是原子表达式，是无法再分解的表达式。

#### 总结：分类如下
* 单值表达式：不使用运算符的表达式
* 简单表达式：不能再分解的表达式
* 复杂表达式：需要其它表达式参与的表达式
* 复合表达式：由运算符将多个单值表达式结合而成的表达式所有表达式均有返回值

****************************************************************************************************
****************************************************************************************************

### JSON对象
* JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式
* 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。被写入ECMAScript 5，成为标准的一部分。
复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。
* 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。字符串必须使用双引号表示，不能使用单引号。
* 对象的键名必须放在双引号里面。
* 数组或对象最后一个成员的后面，不能加逗号。
* JSON.stringify方法将各种类型的值，转成 JSON 字符串。如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。
* 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。
* JSON.stringify方法会忽略对象的不可遍历属性。正则对象会被转成空对象。
* JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。
* 如果对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。
* JSON.stringify发现参数对象有toJSON方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。
* Date对象就有一个自己的toJSON方法。
* toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。
* JSON.parse方法用于将JSON字符串转化成对象。为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。

****************************************************************************************************
****************************************************************************************************

### console对象
* console对象是 JavaScript 的原生对象，它有点像 Unix系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。

#### console的常见用途有两个。
* console.log方法用于在控制台输出信息。它可以接受多个参数，将它们的结果连接起来输出。
* console.log方法会自动在每次输出的结尾，添加换行符。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
* %s 字符串
* %d 整数
* %i 整数
* %f 浮点数
* %o 对象的链接
* %c CSS格式字符串
* console.info()和console.debug()都是console.log方法的别名，用法完全一样。只不过console.info方法会在输出信息的前面，加上一个蓝色图标。
* **console.warn()，console.error()**
* warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。其他方面都一样。
* 复合型数据转为表格显示的条件是，必须拥有主键。对于数组来说，主键就是数字键。对于对象来说，主键就是它的最外层键。

#### 其他console对象上的的方法
* console.count(),console.dir()，console.dirxml(), console.assert(),console.time()，console.timeEnd(),console.group()，console.groupend()，console.groupCollapsed(),console.trace()，console.clear()

****************************************************************************************************
****************************************************************************************************

### 命令行 API
* 控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。

#### debugger语句
* 在Chrome浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开控制台界面。
* JavaScript提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。
提供6个元属性。
1. value存放该属性的属性值，默认为undefined
2. writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。
3. enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。
4. configurable存放一个布尔值，表示“可配置性”，默认为true。
get存放一个函数，表示该属性的取值函数（getter），默认为undefined。
5. set存放一个函数，表示该属性的存值函数（setter），默认为undefined。
6. Object.getOwnPropertyDescriptor方法可以读出对象自身属性的属性描述对象。
* Object.defineProperty方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。
* 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。

****************************************************************************************************
****************************************************************************************************

### 正则表达式
+ 正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用作按照“给定模式”匹配文本的工具。JavaScript 的正则表达式体系是参照 Perl 5 建立的。
+ 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。
+ 字面量和构造函数——在运行时有一个细微的区别。采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。
+ **弱类型、强类型、动态类型、静态类型语言**的字面量和构造函数——在运行时有一个细微的区别。采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。

* ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。
* global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。
* multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。
* lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。
* source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。
* 正则对象使用了g修饰符，表示要记录搜索位置。接着，三次使用test方法，每一次开始搜索的位置都是上一次匹配的后一个位置。
* 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。
* 正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。
* 正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。
* *模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。*

#### 字符串对象的正则方法
> match()：返回一个数组，成员是所有匹配的子字符串。
> search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
> replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。
> split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

#### 匹配规则
* 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。
* 还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters）
1. 点字符（.)
点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
2. 位置字符
位置字符用来提示字符所处的位置，主要有两个字符。
^ 表示字符串的开始位置
$ 表示字符串的结束位置
3. 选择符（|）
竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。
4. 转义符 
正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

#### 字符类
* 字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。
1. 脱字符（^）
如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。
2. 连字符（-）
于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。

#### 重复类
* 模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。? 问号表示某个模式出现0次或1次，等同于{0, 1}。* 星号表示某个模式出现0次或多次，等同于{0,}。+ 加号表示某个模式出现1次或多次，等同于{1,}。
* 默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。

#### 修饰符
* 修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。修饰符可以单个使用，也可以多个一起使用。
* g修饰符表示全局匹配（global）
* 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。
* m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。